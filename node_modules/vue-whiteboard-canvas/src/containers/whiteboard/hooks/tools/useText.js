import {useWhiteboardStore} from "../../store/whiteboard";
import {useHistoryStore} from "../../store/history";
import {useQuillStore} from "../../store/quill";
import Quill from "quill";
import html2canvas from "html2canvas";
import {saveDelta, loadDelta} from "../../utils/delta-store";
import useCursorStyle from "../styles/useCursorStyle";
import { ref } from 'vue';
import {addOutlineOnHover} from "../../utils/konva/shape-effect";
import {getRelativePointerPosition} from "../../utils/konva/pointer";

const {
  states,
  stage,
  currentDrawingObject,
  lastMouseClickPos,
  lastMouseClickAbsPos,
  tempLayer,
  isFirstClick,
  isSecondClick,
  setToolSelected,
  toolSelected,
  layer
} = useWhiteboardStore();
const { record } = useHistoryStore();
const { editor, quill, removeQuillEditor, removeQuillToolbar } = useQuillStore();

const firstClickPos = {
  xPos: 0,
  yPos: 0,
}
const loadQuill = () => {
  editor.value =  new Quill(quill.value, {
    modules: {
      toolbar: [
        [{ 'font': [] }, { 'size': [] }],
        [ 'bold', 'italic', 'underline', 'strike' ],
        [{ 'color': [] }, { 'background': [] }],
        [{ 'script': 'super' }, { 'script': 'sub' }],
        [{ 'header': '1' }, { 'header': '2' }, 'blockquote', 'code-block' ],
        [{ 'list': 'ordered' }, { 'list': 'bullet'}, { 'indent': '-1' }, { 'indent': '+1' }],
        [ 'direction', { 'align': [] }],
        // [ 'link', 'image', 'video', 'formula' ],
        [ 'clean' ]
      ],
    },
    theme: 'snow',
  });
}

const quillImage = ref({});

const swapImageWithQuill = async () => {

  // find delta from index db
  const delta = await loadDelta(quillImage.value.id());
  // get shape position
  const position = quillImage.value.absolutePosition();
  const parentposition = quillImage.value.position();

  // change current tool to text
  setToolSelected('text');

  // change last clicked position to change the position of quill container
  [lastMouseClickAbsPos.xPos, lastMouseClickAbsPos.yPos] = [position.x, position.y]

  // change counter to be first click as we want to trigger the second click logic when we clicked away
  states.clickCounter = 1;
  [firstClickPos.xPos, firstClickPos.yPos] = [parentposition.x, parentposition.y]



  // destroy quillImage.value
  quillImage.value.destroy();
  // load quill instance on shape position
  removeQuillToolbar();

  loadQuill();

  // // load delta into quill instance
  editor.value.setContents(delta);
  layer.value.draw();
}

const isQuillContentEmpty = () => {
  // count number of \n and spaces
  const spaceNumber = editor.value.getText().match(/\n/g).length;
  // if content length === num of spaces that means quill is empty
  const contentLength = editor.value.getLength();
  return spaceNumber === contentLength;
}

const swapQuillWithImage = async () => {
  // turn quill to img via html2canvas
  // get quill content delta
  const content = editor.value.getContents();

  // if content is empty dont need to save
  if(!isQuillContentEmpty()){
    // store quill data in local Forage
    const deltaId = await saveDelta(content);

    const dom = document.querySelector('#quill-container .ql-editor');

    // call html2canvas
    const canvas = await html2canvas(dom, {backgroundColor: "rgba(0,0,0,0)"})

    // create new image shape in konva
    const image = new Konva.Image({
      id: deltaId,
      x: firstClickPos.xPos,
      y: firstClickPos.yPos,
      fill: 'transparent',
      draggable: true,
    });
    addOutlineOnHover(image, 'text');

    quillImage.value = image;

    quillImage.value.on('mousedown touchstart', function (event){
      event.cancelBubble = true;
      // if current tool is text, save the last editing text if available
      quillImage.value = image;
      swapImageWithQuill(event);
    });

    layer.value.add(quillImage.value);
    quillImage.value.image(canvas);
    layer.value.draw();
  }

  // remove editor
  removeQuillEditor();
}

export default () => {

  const onTextMouseDown = async () => {

    if(isSecondClick()){

      await swapQuillWithImage();
      record();
      // reset counter
      states.clickCounter = 0;

      return;
    }

    // first click
    [firstClickPos.xPos, firstClickPos.yPos] = [lastMouseClickPos.xPos, lastMouseClickPos.yPos]
    if(editor.value instanceof Quill){
      // everytime a new quill instance is loaded, we need to remove the existing toolbar node in DOM
      removeQuillToolbar();
    }
    loadQuill();

    // place text box on the mouse position in temp layer

    const clipboard = quill.value.querySelector('.ql-clipboard');
    clipboard.setAttribute('style', 'display: none;')
    editor.value.focus();

  }

  const onTextMouseMove = () => {

  }

  const onTextMouseUp = () => {

  }

  return {
    quillImage,
    swapImageWithQuill,
    swapQuillWithImage,
    onTextMouseDown,
    onTextMouseMove,
    onTextMouseUp,
  }

}
