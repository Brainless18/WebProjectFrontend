import {ref} from 'vue';
import Konva from "konva";
import {useWhiteboardStore} from "../../store/whiteboard";
import {useTransformer} from "../../utils/transformer/transformer";
import {getRelativePointerPosition} from "../../utils/konva/pointer";
import {useHistoryStore} from "../../store/history";

const selectionRectangle = ref(new Konva.Rect({
  fill: 'rgba(0,0,255,0.5)',
}));

const selectionStartX1 = ref(0);
const selectionStartY1 = ref(0);

const moveStates = {
  isDragging: false,
}
const {record} = useHistoryStore();
const {layer, tempLayer, stage} = useWhiteboardStore();
const {
  setTransformerNodes,
  clearTransformer,
  removeTransformerNode,
  addNodeToTransformer,
  isNodeInTransformer,
  initTransformer,
} = useTransformer();

const onClickShape = (event) => {
  console.log('clicked on shape');

  moveStates.isDragging = true;
  // do we pressed shift or ctrl?
  const metaPressed = event.evt.shiftKey || event.evt.ctrlKey || event.evt.metaKey;
  const isSelected = isNodeInTransformer(event.target);

  if (!metaPressed && !isSelected) {
    // if no key pressed and the node is not selected
    // select just one
    console.log('selected');
    setTransformerNodes([event.target]);

  } else if (metaPressed && isSelected) {
    // if we pressed keys and node was selected
    // we need to remove it from selection:
    console.log('remove transformer node');
    removeTransformerNode(event.target);
  } else if (metaPressed && !isSelected) {
    // add the node into selection
    console.log('add node to transformer');
    addNodeToTransformer(event.target);
  }
  layer.value.batchDraw();
}

const onMoveMouseDown = (event) => {
  console.log('on move mouse down');

  // do nothing if we mousedown on eny shape
  if (!(event.target instanceof Konva.Stage)) {
    // clicked on a shape
    onClickShape(event);
    return;
  }
  // clicking on empty area on stage
  clearTransformer();
  selectionStartX1.value = getRelativePointerPosition(stage.value).x;
  selectionStartY1.value = getRelativePointerPosition(stage.value).y;

  selectionRectangle.value.visible(true);
  selectionRectangle.value.width(0);
  selectionRectangle.value.height(0);
  tempLayer.value.add(selectionRectangle.value);

  tempLayer.value.batchDraw();
}

const onMoveMouseMove = (x, y) => {
  // no nothing if we didn't start selection
  if (!(selectionRectangle.value.isVisible())) {
    return;
  }

  selectionRectangle.value.setAttrs({
    x: Math.min(selectionStartX1.value, x),
    y: Math.min(selectionStartY1.value, y),
    width: Math.abs(x - selectionStartX1.value),
    height: Math.abs(y - selectionStartY1.value),
  });
  tempLayer.value.batchDraw();
}

const onMoveMouseUp = (event) => {
  if(moveStates.isDragging){
    record();
    moveStates.isDragging = false;
  }
  // no nothing if we didn't start selection
  if (!(selectionRectangle.value.isVisible())) {
    return;
  }
  const box = selectionRectangle.value.getClientRect();

  selectionRectangle.value.visible(false);

  const shapes = layer.value.getChildren().toArray();
  const selected = shapes.filter((shape) => {

    return !(shape instanceof Konva.Transformer) && Konva.Util.haveIntersection(box, shape.getClientRect())
  });
  console.log('filtered', selected);
  setTransformerNodes(selected);

  tempLayer.value.batchDraw();
  layer.value.batchDraw();
}

export default () => {
  return {
    selectionRectangle,
    onMoveMouseDown,
    onMoveMouseMove,
    onMoveMouseUp,
  }
}
