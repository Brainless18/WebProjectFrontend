import {useWhiteboardStore} from "../../../store/whiteboard";


const {stage} = useWhiteboardStore();


const onWheel = (event) => {
  event.evt.preventDefault();
  const scaleBy = 1.1 ;

  console.log('scalex', stage.value.scaleX())

  // let newScale = (event.evt.deltaY < 0 ? oldScale.value * scaleBy : oldScale.value / scaleBy);
  const pointer = stage.value.getPointerPosition();

  const oldScale = stage.value.scaleX();

  const mousePointTo = {
    x: (pointer.x - stage.value.x()) / oldScale,
    y: (pointer.y - stage.value.y()) / oldScale,
  };

  const newScale = event.evt.deltaY < 0 ? oldScale * scaleBy : oldScale / scaleBy;

  stage.value.scale({ x: newScale, y: newScale });

  const newPos = {
    x: pointer.x - mousePointTo.x * newScale,
    y: pointer.y - mousePointTo.y * newScale,
  };
  stage.value.position(newPos);


  // deprecated since 19/11/2020: using solution above, fixed by get relative mouse position
  // -- this is 'hacking the zoom'
  // -- looping thru each element and scale them accordingly. Not efficient if we have a lot of nodes
  // layer.value.getChildren().forEach((node) => {
  //   const oldScale = node.scale().x;
  //   const newScale = (event.evt.deltaY < 0 ? oldScale * scaleBy : oldScale / scaleBy);
  //   node.scale({ x: newScale, y: newScale });
  //
  //   // const mousePointTo = {
  //   //   x: (pointer.x - layer.value.x()) / oldScale,
  //   //   y: (pointer.y - layer.value.y()) / oldScale,
  //   // };
  //   //
  //   // const newPos = {
  //   //   x: pointer.x - mousePointTo.x * newScale,
  //   //   y: pointer.y - mousePointTo.y * newScale,
  //   // };
  //   // layer.value.position(newPos);
  //
  // })

  stage.value.batchDraw();

}

export {onWheel}
